#!/usr/bin/env python
# coding: utf-8

# In[17]:


#Import Libraries
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
import matplotlib.mlab as mlab
import matplotlib.gridspec as gridspec
import scipy as sp


# ## The following code processes data formatted in a standardized Excel template which can be found on github

# In[18]:


#IMPORT THE DATABASE FILE
db_raw = pd.read_excel('BldgInfo FINAL.xlsx', sheet_name = 'Grading Parameter inputs', skiprows = [0])
db_grades = pd.read_excel('BldgInfo FINAL.xlsx', sheet_name = 'Grade Scores')
db_cols = ['Building No.','Typology Est', 'Dominant Matl', 'SDC', 'ortho_conn', 'level_ties', 'mas_qual',           'mas_type', 'size_reg', 'rc_fdn', 'soil', 'slope',           't_k', 'no_storeys', 'A_plan', 'h_b', 'p_m', 'w_d', 'L_x', 't_x', 'L_y',           't_y', 'L', 'a', 'b', 'del_mass', 'A_arcade', 'fl_type',           'wall_conn_qual', 'fl_stag', 'multi_fl', 'roof_type', 'roof_tie',           'perim', 'perim_supp', 'conn_nonstruct', 'conn_overhang', 'superstructure',           'cracks', 'h_adj1', 'h_adj2', 'position', 'no_sides_bounded',           'no_stag_fl', 'adj_matl', 'adj_behav', 'A_open', 'A_adjopen']

#narrow down the table to be only rows of interest
db = db_raw.iloc[0:,0:len(db_cols)]

#rename the columns to make column work easier and get rid of brackets
db = db.set_axis(db_cols, axis = 1, copy = False)

#Just in case there are empty cells, we want to fill them with -1 so we don't get NaN errors
db = db.fillna(-1)
db


# In[19]:


#Create versions of the database that can be appended to later
Grades = db.drop(columns = {'Typology Est', 'Dominant Matl','SDC', 'ortho_conn', 'level_ties', 'mas_qual',           'mas_type', 'size_reg', 'rc_fdn', 'soil', 'slope',           't_k', 'no_storeys', 'A_plan', 'h_b', 'p_m', 'w_d', 'L_x', 't_x', 'L_y',           't_y', 'L', 'a', 'b', 'del_mass', 'A_arcade', 'fl_type',           'wall_conn_qual', 'fl_stag', 'multi_fl', 'roof_type', 'roof_tie',           'perim', 'perim_supp', 'conn_nonstruct', 'conn_overhang', 'superstructure',           'cracks', 'h_adj1', 'h_adj2', 'position', 'no_sides_bounded',           'no_stag_fl', 'adj_matl', 'adj_behav', 'A_open', 'A_adjopen'})
base = db.drop(columns = {'Typology Est', 'Dominant Matl','SDC', 'ortho_conn', 'level_ties', 'mas_qual',           'mas_type', 'size_reg', 'rc_fdn', 'soil', 'slope',           't_k', 'no_storeys', 'A_plan', 'h_b', 'p_m', 'w_d', 'L_x', 't_x', 'L_y',           't_y', 'L', 'a', 'b', 'del_mass', 'A_arcade', 'fl_type',           'wall_conn_qual', 'fl_stag', 'multi_fl', 'roof_type', 'roof_tie',           'perim', 'perim_supp', 'conn_nonstruct', 'conn_overhang', 'superstructure',           'cracks', 'h_adj1', 'h_adj2', 'position', 'no_sides_bounded',           'no_stag_fl', 'adj_matl', 'adj_behav', 'A_open', 'A_adjopen'})


# In[20]:


#COMPLETED - OUTPUT IS ARRAY OF GRADES FOR P1
#GRADES PARAMETER 1: ORGANIZATION OF VERTICAL STRUCTURES
#INPUTS ARE COLUMN INDICES OF YES/NO RESPONSES
def grade_p1(df, sdc_ind, ortho_ind, ties_ind):
    p1 = []
    sdc = df.iloc[:,[sdc_ind]].to_numpy()
    ortho = df.iloc[:,[ortho_ind]].to_numpy()
    ties = df.iloc[:,[ties_ind]].to_numpy()
    for i in np.arange(0,len(df)):
        pot_p1 = []
        if sdc[i] == -1 or ortho[i] == -1 or ties[i] == -1:
            pot_p1 = np.append(pot_p1,'D')
        elif sdc[i] == 'Yes':
            pot_p1 = np.append(pot_p1,'A')
        elif ortho[i] == 'Yes':
            if ties[i] == 'No':
                pot_p1 = np.append(pot_p1,'C')
            else:
                pot_p1 = np.append(pot_p1,'B')
        else:
            pot_p1 = np.append(pot_p1,'D')
        p1 = np.append(p1, max(pot_p1))
    return p1


#COMPLETED - OUTPUT IS ARRAY OF GRADES FOR P2
#GRADES PARAMETER 2: MAKEUP OF VERTICAL STRUCTURES
#INPUTS ARE COLUMNS DESCRIBING MASONRY CHARACTERISTICS
def grade_p2(df, mas_qual_ind, mas_type_ind, size_reg_ind):
    p2 = []
    masqual = df.iloc[:,[mas_qual_ind]].to_numpy()
    mastype = df.iloc[:,[mas_type_ind]].to_numpy()
    sizereg = df.iloc[:,[size_reg_ind]].to_numpy()
    for i in np.arange(0,len(df)):
        pot_p2 = []
        if mastype[i] == 'Irregular stone':
            pot_p2 = np.append(pot_p2,'D')
        elif sizereg[i] == 'Yes'  and mastype[i] == 'Brick' or 'Well-squared stone' or 'Well-squared tuff':
            if masqual[i] == 'Good':
                pot_p2 = np.append(pot_p2,'A')
            elif masqual[i] == 'Adequate': 
                pot_p2 = np.append(pot_p2,'B')
            elif masqual[i] == 'Bad':
                pot_p2 = np.append(pot_p2,'D')
            else:
                pot_p2 = np.append(pot_p2,'C')
        elif masqual[i] == 'Bad' or 'Pebble infill':
            pot_p2 = np.append(pot_p2,'D')
        else:
            pot_p2 = np.append(pot_p2,'C')
        p2 = np.append(p2, max(pot_p2))
    return p2


#COMPLETED - OUTPUT IS ARRAY OF GRADES FOR P3
#GRADES PARAMETER 3: FOUNDATION CONDITIONS
#INPUTS ARE COLUMNS DESCRIBING MASONRY CHARACTERISTICS
def grade_p3(df, rc_fdn_ind, soil_ind, slope_ind):
    p3 = []
    rc = df.iloc[:,[rc_fdn_ind]].to_numpy()
    soil = df.iloc[:,[soil_ind]].to_numpy()
    slope = df.iloc[:,[slope_ind]].to_numpy()
    for i in np.arange(0,len(df)):
        pot_p3 = []
        if rc[i] == 'Yes':
            if soil[i] == 'stable soil' and slope[i] <= 5:
                pot_p3 = np.append(pot_p3,'A')
            elif slope[i] > 5 and slope[i] <= 15:
                pot_p3 = np.append(pot_p3,'B')
            else:
                pot_p3 = np.append(pot_p3,'C')
        elif rc[i] == 'No':
            if soil[i] == 'rocky soil' and slope[i] <=10:
                pot_p3 = np.append(pot_p3,'B')
            elif soil[i] == 'clay soil':
                if slope[i] < 15:
                    pot_p3 = np.append(pot_p3,'C')
                else:
                    pot_p3 = np.append(pot_p3,'D')
            elif soil[i] == 'rocky soil' and slope[i] >=25:
                pot_p3 = np.append(pot_p3,'D')
            else:
                pot_p3 = np.append(pot_p3,'C')
        else:
            pot_p3 = np.append(pot_p3,'C')
        p3 = np.append(p3, max(pot_p3))
    return p3


#COMPLETED - OUTPUT IS ARRAY OF GRADES FOR P4
#GRADES PARAMETER 4: DISTRIBUTION OF LATERAL RESISTING ELEMENTS
#INPUTS ARE 
def grade_p4(df, tau_k_ind, N_ind, A_plan_ind, h_b_ind, p_m_ind, w_d_ind, Lx_ind, tx_ind, Ly_ind, ty_ind):
    p4 = []
    tau = df.iloc[:,[tau_k_ind]].to_numpy()*1000
    N = df.iloc[:,[N_ind]].to_numpy()
    Aplan = df.iloc[:,[A_plan_ind]].to_numpy()
    hb = df.iloc[:,[h_b_ind]].to_numpy()
    pm = df.iloc[:,[p_m_ind]].to_numpy()*.009806
    wd = df.iloc[:,[w_d_ind]].to_numpy()
    Lx = df.iloc[:,[Lx_ind]].to_numpy()
    tx = df.iloc[:,[tx_ind]].to_numpy()
    Ly = df.iloc[:,[Ly_ind]].to_numpy()
    ty = df.iloc[:,[ty_ind]].to_numpy()
    Ax = Lx*tx
    Ay = Ly*ty
    hm = np.zeros(len(Ax))
    A = np.zeros(len(Ax))
    B = np.zeros(len(Ax))
    q = np.zeros(len(Ax))
    a_o = np.zeros(len(Ax))
    alpha = np.zeros(len(Ax))
    for i in np.arange(0,len(Ax)):
        if N[i] == -1 or hm[i] == -1 or A[i] == -1 or B[i] == -1 or a_o[i] == -1 or hb[i] == -1 or pm[i]/0.009806 == -1 or tau[i]/1000 == -1 or Lx[i] == -1 or Ly[i] == -1:
            p4 = np.append(p4, 'D')
        else:
            hm[i] = hb[i]/N[i]
            A[i] = min(Ax[i],Ay[i])
            B[i] = max(Ax[i],Ay[i])
            a_o[i] = A[i]/Aplan[i]
            q[i] = (A[i]+B[i])/Aplan[i]*hm[i]*pm[i]+wd[i]
            alpha[i] = ((a_o[i]*tau[i]/(N[i]*q[i]))*((1+(q[i]*N[i])/(1.5*a_o[i]*tau[i]*(1+B[i]/A[i])))**.5))/0.4
            if alpha[i] >= 1:
                p4 = np.append(p4, 'A')
            elif 0.6 <= alpha[i] < 1:
                p4 = np.append(p4, 'B')
            elif 0.4 <= alpha[i] < 0.6:
                p4 = np.append(p4, 'C')
            elif alpha[i] < 0.4:
                p4 = np.append(p4, 'D')
            else:
                p4 = np.append(p4, 'D')
    return p4


#COMPLETED - OUTPUT IS ARRAY OF GRADES FOR P5
#GRADES PARAMETER 5: PLAN REGULARITY
#INPUTS ARE 
def grade_p5(df, L_ind, a_ind, b_ind):
    p5 = []
    L = df.iloc[:,[L_ind]].to_numpy()
    a = df.iloc[:,[a_ind]].to_numpy()
    b = df.iloc[:,[b_ind]].to_numpy()
    B1 = np.zeros(len(df))
    B2 = np.zeros(len(df))
    for i in np.arange(0,len(df)):
        B1[i] = a[i]/L[i]
        B2[i] = b[i]/L[i]
        pot_p5 = []
        if L[i] == -1 or a[i] == -1 or b[i] == -1:
            pot_p5 = np.append(pot_p5, 'D')
        elif B1[i] >= 0.8:
            pot_p5 = np.append(pot_p5, 'A')
        elif 0.8 > B1[i] >= 0.6:
            pot_p5 = np.append(pot_p5, 'B')
        elif B1[i] < 0.4:
            pot_p5 = np.append(pot_p5, 'D')
        else:
            pot_p5 = np.append(pot_p5, 'C')
        if B2[i] <= 0.1:
            pot_p5 = np.append(pot_p5, 'A')
        elif 0.1 < B2[i] <= 0.2:
            pot_p5 = np.append(pot_p5, 'B')
        elif 0.3 < B2[i]:
            pot_p5 = np.append(pot_p5, 'D')
        else:
            pot_p5 = np.append(pot_p5, 'C')
        p5 = np.append(p5, max(pot_p5))
    return p5


#COMPLETE - OUTPUT IS ARRAY OF GRADES FOR P6
#GRADES PARAMETER 6: VERTICAL REGULARITY
#INPUTS ARE 
def grade_p6(df, Aplan_ind, delmass_ind, a_arc_ind):
    p6 = []
    Ap = df.iloc[:,[Aplan_ind]].to_numpy()
    delmass = df.iloc[:,[delmass_ind]].to_numpy()
    Aarc = df.iloc[:,[a_arc_ind]].to_numpy()
    for i in np.arange(0,len(df)):
        pot_p6 = []
        if Ap[i] == -1 or delmass[i] == -1 or Aarc[i] == -1:
            pot_p6 = np.append(pot_p6, 'D')
        elif delmass[i] < .1 or Aarc[i] == 0:
            pot_p6 = np.append(pot_p6, 'A')
        elif 0.1 < delmass[i] <= .2 or 0 < Aarc[i] < .1:
            pot_p6 = np.append(pot_p6, 'B')
        elif delmass[i] > .2 or 0.1 <= Aarc[i] < .2:
            pot_p6 = np.append(pot_p6, 'B')
        else: 
            pot_p6 = np.append(pot_p6, 'D')
        p6 = np.append(p6, max(pot_p6))
    return p6


#OUTPUT IS ARRAY OF GRADES FOR P7
#GRADES PARAMETER 7: TYPE OF FLOOR
#INPUTS ARE AS FOLLOWS
def grade_p7(df, f_typ_ind, wall_conn_qual_ind, fl_stag_ind, multi_fl_ind):
    p7 = []
    fltyp = df.iloc[:,[f_typ_ind]].to_numpy()
    wallconn = df.iloc[:,[wall_conn_qual_ind]].to_numpy()
    flstag = df.iloc[:,[fl_stag_ind]].to_numpy()
    multifl = df.iloc[:,[multi_fl_ind]].to_numpy()
    for i in np.arange(0,len(df)):
        pot_p7 = []
        if fltyp[i] == 'rigid' and wallconn[i] == 'Good':
            if flstag[i] == 'No':
                pot_p7 = np.append(pot_p7, 'A')
            elif multifl[i] == 'Yes':
                pot_p7 = np.append(pot_p7, 'D')
            else:
                pot_p7 = np.append(pot_p7, 'B')
        elif fltyp[i] == 'flexible' and wallconn[i] == 'Good':
            pot_p7 = np.append(pot_p7, 'C')
        else:
            pot_p7 = np.append(pot_p7, 'D')
        p7 = np.append(p7, max(pot_p7))
    return p7


#TO DO - OUTPUT IS ARRAY OF GRADES FOR P8
#GRADES PARAMETER 8: ROOFING SYSTEM AND COVERAGE
#INPUTS ARE 
def grade_p8(df, rf_type_ind, rf_tie_ind):
    p8 = []
    rftype = df.iloc[:,[rf_type_ind]].to_numpy()
    rftie = df.iloc[:,[rf_tie_ind]].to_numpy()
    for i in np.arange(0,len(df)):
        if rftype[i] == 'Non-pushing':
            if rftie[i] == 'Yes':
                p8 = np.append(p8, 'A')
            else:
                p8 = np.append(p8, 'B')
        elif rftype[i] == 'Little-pushing':
            if rftie[i] == 'Yes':
                p8 = np.append(p8, 'B')
            else:
                p8 = np.append(p8, 'C')
        elif rftype[i] == 'Pushing':
            if rftie[i] == 'Yes':
                p8 = np.append(p8, 'C')
            else:
                p8 = np.append(p8, 'D')
        else:
            p8 = np.append(p8, 'D')
    return p8


#TO DO - OUTPUT IS ARRAY OF GRADES FOR P9
#GRADES PARAMETER 9: QUALITY OF DETAILS AND APPENDAGES
#INPUTS ARE 
def grade_p9(df, conn_ns_ind, conn_oh_ind, ss_ind):
    p9 = []
    ns = df.iloc[:,[conn_ns_ind]].to_numpy()
    oh = df.iloc[:,[conn_oh_ind]].to_numpy()
    ss = df.iloc[:,[ss_ind]].to_numpy()
    for i in np.arange(0,len(df)):
        if ss[i] == 'Yes' or oh[i] == 'Poor':
            p9 = np.append(p9, 'D')
        elif ns[i] == 'Poor':
            p9 = np.append(p9, 'C')
        else:
            p9 = np.append(p9, 'B')
    return p9


#TO DO - OUTPUT IS ARRAY OF GRADES FOR P10
#GRADES PARAMETER 10: PHYSICAL CONDITION
#INPUTS ARE 
def grade_p10(df, crack_ind):
    p10 = []
    crack = df.iloc[:,[crack_ind]].to_numpy()
    for i in np.arange(0,len(df)):
        if crack[i] == 'none':
            p10 = np.append(p10, 'A')
        elif crack[i] == 'minor capillary':
            p10 = np.append(p10, 'B')
        elif crack[i] == 'large cracks, partial collapse, unsafe, or poorly preserved':
            p10 = np.append(p10, 'D')
        else:
            p10 = np.append(p10, 'C')
    return p10


#OUTPUT IS ARRAY OF GRADES FOR P11
#GRADES PARAMETER 11: INTERACTION WITH ADJACENT BUILDINGS
#INPUTS ARE THE COMPARATIVE HEIGHT OF AN ADJACENT BUILDING
def grade_p11(df, adj1_ind, adj2_ind):
    p11 = []
    adj1 = df.iloc[:,[adj1_ind]].to_numpy()
    adj2 = df.iloc[:,[adj2_ind]].to_numpy()
    for i in np.arange(0,len(df)):
        pot_p11 = []
        if adj1[i] == 'equal' and adj2[i] == 'equal':
            p11 = np.append(p11, 'A')
        elif adj1[i] == 'taller' and adj2[i] == 'equal':
            p11 = np.append(p11, 'B')
        elif adj2[i] == 'taller' and adj1[i] == 'equal':
            p11 = np.append(p11, 'B')
        elif adj1[i] == 'lower' and adj2[i] == 'lower':
            p11 = np.append(p11, 'D')
        else:
            p11 = np.append(p11, 'C')
    return p11


#TO DO - OUTPUT IS ARRAY OF GRADES FOR P12
#GRADES PARAMETER 12: POSITION WITHIN AGGREGATE
#INPUTS ARE 
def grade_p12(df, pos_ind, bound_ind):
    p12 = []
    pos = df.iloc[:,[pos_ind]].to_numpy()
    bound = df.iloc[:,[bound_ind]].to_numpy()
    for i in np.arange(0,len(df)):
        if pos[i] == 'corner':
            p12 = np.append(p12, 'C')
        elif pos[i] == 'heading':
            p12 = np.append(p12, 'D')
        elif pos[i] == 'intermediate':
            if bound[i] == '3+':
                p12 = np.append(p12, 'A')
            else:
                p12 = np.append(p12, 'B')
        else:
            p12 = np.append(p12, 'A')
    return p12


#COMPLETE - OUTPUT IS ARRAY OF GRADES FOR P13
#GRADES PARAMETER 13: STAGGERED FLOORS
#INPUTS ARE 
def grade_p13(df, no_stag_ind):
    p13 = []
    nostag = df.iloc[:,[no_stag_ind]].to_numpy()
    for i in np.arange(0,len(df)):
        if nostag[i] == 0:
            p13 = np.append(p13, 'A')
        elif nostag[i] == 1:
            p13 = np.append(p13, 'B')
        elif nostag[i] == 2:
            p13 = np.append(p13, 'C')
        else:
            p13 = np.append(p13, 'D')
    return p13


#COMPLETE - OUTPUT IS ARRAY OF GRADES FOR P14
#GRADES PARAMETER 14: STRUCTURAL HETEROGENEITY
#INPUTS ARE 
def grade_p14(df, adj_mat_ind, adj_behav_ind):
    p14 = []
    adjmat = df.iloc[:,[adj_mat_ind]].to_numpy()
    adjbeh = df.iloc[:,[adj_behav_ind]].to_numpy()
    for i in np.arange(0,len(df)):
        pot_p14 = []
        if adjbeh[i] == 'different':
            p14 = np.append(p14, 'D')
        elif adjmat[i] == 'same':
            p14 = np.append(p14, 'A')
        elif adjmat[i] == 'different':
            p14 = np.append(p14, 'C')
        else:
            p14 = np.append(p14, 'B')
    return p14


#TO DO - OUTPUT IS ARRAY OF GRADES FOR P15
#GRADES PARAMETER 15: PERCENTAGE DIFFERENCE OF OPENINGS
#INPUTS ARE 
def grade_p15(df, A_open_ind, A_adj_ind):
    p15 = []
    Aopen = df.iloc[:,[A_open_ind]].to_numpy()
    Aadj = df.iloc[:,[A_adj_ind]].to_numpy()
    for i in np.arange(0,len(df)):
        if Aopen[i] > 0:
            diff = abs((Aopen[i]-Aadj[i])/Aopen[i])*100
            if diff <= 5:
                p15 = np.append(p15, 'A')
            elif 5 < diff <= 10:
                p15 = np.append(p15, 'B')
            elif 10 < diff <= 20:
                p15 = np.append(p15, 'C')
            else:
                p15 = np.append(p15, 'D')
        else:
            p15 = np.append(p15, 'D')
    return p15


# ## Building Stock Information

# In[21]:


def damstate(df, crack_ind):
    D = []
    crack = df.iloc[:,[crack_ind]].to_numpy()
    for i in np.arange(0,len(df)):
        if crack[i] == 'none':
            D = np.append(D, 'D0')
        elif crack[i] == 'minor capillary':
            D = np.append(D, 'D1')
        elif crack[i] == 'medium sized':
            D = np.append(D, 'D3')
        elif crack[i] == 'large cracks, partial collapse, unsafe, or poorly preserved':
            D = np.append(D, 'D4')
        else:
            D = np.append(D, 'D2')
    return D


def typology(df, dom_material_ind):
    T = []
    dommat = df.iloc[:,[dom_material_ind]].to_numpy()
    for i in np.arange(0,len(df)):
        if dommat[i] == 'Rubble Stone':
            T = np.append(T,'M1')
        elif dommat[i] == 'Adobe':
            T = np.append(T,'M2')
        elif dommat[i] == 'Simple Stone':
            T = np.append(T,'M3')
        elif dommat[i] == 'Massive Stone':
            T = np.append(T,'M4')
        elif dommat[i] == 'URM (Old Bricks)':
            T = np.append(T,'M5')
        elif dommat[i] == 'URM with RC floors':
            T = np.append(T,'M6')
        elif dommat[i] == 'Reinforced/Confined Masonry':
            T = np.append(T,'M7')
        else:
            T = np.append(T,'NC')
    return T


# In[22]:


stock = db.drop(columns = {'SDC', 'ortho_conn', 'level_ties', 'mas_qual',           'mas_type', 'size_reg', 'rc_fdn', 'soil', 'slope',           't_k', 'h_b', 'p_m', 'w_d', 'L_x', 't_x', 'L_y',           't_y', 'L', 'a', 'b', 'del_mass', 'A_arcade', 'fl_type',           'wall_conn_qual', 'fl_stag', 'multi_fl', 'roof_type', 'roof_tie',           'perim', 'perim_supp', 'conn_nonstruct', 'conn_overhang', 'superstructure',           'cracks', 'h_adj1', 'h_adj2', 'position', 'no_sides_bounded',           'no_stag_fl', 'adj_matl', 'adj_behav', 'A_open', 'A_adjopen'})
stock['Damage State'] = damstate(db, 38)
stock['Typology'] = typology(db, 2)
types = stock['Typology'].value_counts(sort = False)
dams = stock['Damage State'].value_counts(sort = False)
stock = stock.rename(columns={"no_storeys":"No. of Storeys", "A_plan": "Plan Area [m2]"})
stor = stock['No. of Storeys'].value_counts(sort = False).dropna


# In[23]:


stock


# In[24]:


D0ct = D1ct = D2ct = D3ct = D4ct = D5ct = 0

for i in np.arange(0,len(stock)):
    if stock.iloc[i,5] == 'D0':
        D0ct += 1
    elif stock.iloc[i,5] == 'D1':
        D1ct += 1
    elif stock.iloc[i,5] == 'D2':
        D2ct += 1
    elif stock.iloc[i,5] == 'D3':
        D3ct += 1
    elif stock.iloc[i,5] == 'D4':
        D4ct += 1
    elif stock.iloc[i,5] == 'D5':
        D5ct += 1
    else:
        print('error')

damage_counts = pd.DataFrame({'Counts':[D0ct,D1ct,D2ct,D3ct,D4ct,D5ct]}, index = ['D0','D1','D2','D3','D4','D5'])
damage_counts


# In[25]:


fig, ax = plt.subplots()

sns.countplot(x = stock['Typology'], order = ['M1','M2','M3','M4','M5','M6','M7','RC1','NC'], ax = ax)
#.step(list(types.sort_index().index),np.cumsum(types.sort_index()), color = 'r')


# In[26]:


fig, ax = plt.subplots(figsize = (4,6))

sns.countplot(x = stock['Damage State'], order = ['D0','D1','D2','D3','D4','D5'], ax = ax)


# In[27]:


fig,axs = plt.subplots(1, 2, figsize = (12,8))

axs[0].step(list(types.sort_index().index),np.cumsum(types.sort_index()), color = 'r')
axs[0].bar(list(types.sort_index().index),types.sort_index(), ec = 'black')
axs[0].set_title('Distribution of Building Types')
axs[0].set_xlabel('Typology')
axs[0].set_ylabel('Number')


axs[1].bar(list(dams.sort_index().index),dams, ec = 'black')
axs[1].step(list(dams.sort_index().index),np.cumsum(dams), color = 'r')
axs[1].set_title('Distribution of Damage States')
axs[1].set_xlabel('Damage State')
axs[1].set_ylabel('Number')


# In[28]:


stock.to_excel(r'C:\Users\mason\Desktop\MCM SAHC\Courses\SA7 - Integrated Group Project\SA7 Code\bldgstockdata final.xlsx')


# # Vulnerability Grading

# In[29]:


Grades['P1'] = grade_p1(db, 3, 4, 5)
Grades['P2'] = grade_p2(db, 6, 7, 8)
Grades['P3'] = grade_p3(db, 9, 10, 11)
Grades['P4'] = grade_p4(db, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21)
Grades['P5'] = grade_p5(db, 22, 23, 24)
Grades['P6'] = grade_p6(db, 14, 25, 26)
Grades['P7'] = grade_p7(db, 27, 28, 29, 30)
Grades['P8'] = grade_p8(db, 31, 32)
Grades['P9'] = grade_p9(db, 35,36,37)
Grades['P10'] = grade_p10(db, 38)
Grades['P11'] = grade_p11(db,39,40)
Grades['P12'] = grade_p12(db, 41, 42)
Grades['P13'] = grade_p13(db, 43)
Grades['P14'] = grade_p14(db, 44,45)
Grades['P15'] = grade_p15(db, 46, 47)


# In[30]:


Grades.to_excel(r'C:\Users\mason\Desktop\MCM SAHC\Courses\SA7 - Integrated Group Project\SA7 Code\ParameterGrades final.xlsx')


# In[31]:


w1 = 1
w2 = 0.25
w3 = 0.75
w4 = 1.5
w5 = 0.5
w6 = 0.5
w7 = .8
w8 = 0.75
w9 = 0.25
w10 = 1
w11 = 1
w12 = 1.5
w13 = 0.5
w14 = 1.2
w15 = 1
weights = [w1,w2,w3,w4,w5,w6,w7,w8,w9,w10,w11,w12,w13,w14,w15]


# # Vulnerability Index, Iv of Building 1

# In[32]:


#Building 1 only
b1grades = Grades.iloc[0,1:len(db_grades)+1]
iv_comps = []
Iv = []
for i in np.arange(0,len(b1grades)):
    if b1grades[i] == 'A':
        ind = 1
    elif b1grades[i] == 'B':
        ind = 2
    elif b1grades[i] == 'C':
        ind = 3
    elif b1grades[i] == 'D':
        ind = 4
    s = db_grades.iloc[i,ind]
    wt = db_grades.iloc[i,5]
    iv_comps = np.append(iv_comps, s*wt)
Iv = sum(iv_comps)
print("Iv for Building 1 =", Iv)


# # Vulnerability Index, Iv and Vi of all Buildings

# In[33]:


#For all buildings
Scores = db.drop(columns = {'SDC', 'ortho_conn', 'level_ties', 'mas_qual',           'mas_type', 'size_reg', 'rc_fdn', 'soil', 'slope',           't_k', 'no_storeys', 'A_plan', 'h_b', 'p_m', 'w_d', 'L_x', 't_x', 'L_y',           't_y', 'L', 'a', 'b', 'del_mass', 'A_arcade', 'fl_type',           'wall_conn_qual', 'fl_stag', 'multi_fl', 'roof_type', 'roof_tie',           'perim', 'perim_supp', 'conn_nonstruct', 'conn_overhang', 'superstructure',           'cracks', 'h_adj1', 'h_adj2', 'position', 'no_sides_bounded',           'no_stag_fl', 'adj_matl', 'adj_behav', 'A_open', 'A_adjopen'})
grademap1 = {'A':db_grades.iloc[0,1]*db_grades.iloc[0,5],'B':db_grades.iloc[0,2]*db_grades.iloc[0,5],'C':db_grades.iloc[0,3]*db_grades.iloc[0,5],'D':db_grades.iloc[0,4]*db_grades.iloc[0,5]}
Scores['P1'] = Grades.iloc[:,1].map(grademap1).to_numpy()
grademap2 = {'A':db_grades.iloc[1,1]*db_grades.iloc[1,5],'B':db_grades.iloc[1,2]*db_grades.iloc[1,5],'C':db_grades.iloc[1,3]*db_grades.iloc[1,5],'D':db_grades.iloc[1,4]*db_grades.iloc[1,5]}
Scores['P2'] = Grades.iloc[:,2].map(grademap2).to_numpy()
grademap3 = {'A':db_grades.iloc[2,1]*db_grades.iloc[2,5],'B':db_grades.iloc[2,2]*db_grades.iloc[2,5],'C':db_grades.iloc[2,3]*db_grades.iloc[2,5],'D':db_grades.iloc[2,4]*db_grades.iloc[2,5]}
Scores['P3'] = Grades.iloc[:,3].map(grademap3).to_numpy()
grademap4 = {'A':db_grades.iloc[3,1]*db_grades.iloc[3,5],'B':db_grades.iloc[3,2]*db_grades.iloc[3,5],'C':db_grades.iloc[3,3]*db_grades.iloc[3,5],'D':db_grades.iloc[3,4]*db_grades.iloc[3,5]}
Scores['P4'] = Grades.iloc[:,4].map(grademap4).to_numpy()
grademap5 = {'A':db_grades.iloc[4,1]*db_grades.iloc[4,5],'B':db_grades.iloc[4,2]*db_grades.iloc[4,5],'C':db_grades.iloc[4,3]*db_grades.iloc[4,5],'D':db_grades.iloc[4,4]*db_grades.iloc[4,5]}
Scores['P5'] = Grades.iloc[:,5].map(grademap5).to_numpy()
grademap6 = {'A':db_grades.iloc[5,1]*db_grades.iloc[5,5],'B':db_grades.iloc[5,2]*db_grades.iloc[5,5],'C':db_grades.iloc[5,3]*db_grades.iloc[5,5],'D':db_grades.iloc[5,4]*db_grades.iloc[5,5]}
Scores['P6'] = Grades.iloc[:,6].map(grademap6).to_numpy()
grademap7 = {'A':db_grades.iloc[6,1]*db_grades.iloc[6,5],'B':db_grades.iloc[6,2]*db_grades.iloc[6,5],'C':db_grades.iloc[6,3]*db_grades.iloc[6,5],'D':db_grades.iloc[6,4]*db_grades.iloc[6,5]}
Scores['P7'] = Grades.iloc[:,7].map(grademap7).to_numpy()
grademap8 = {'A':db_grades.iloc[7,1]*db_grades.iloc[7,5],'B':db_grades.iloc[7,2]*db_grades.iloc[7,5],'C':db_grades.iloc[7,3]*db_grades.iloc[7,5],'D':db_grades.iloc[7,4]*db_grades.iloc[7,5]}
Scores['P8'] = Grades.iloc[:,8].map(grademap8).to_numpy()
grademap9 = {'A':db_grades.iloc[8,1]*db_grades.iloc[8,5],'B':db_grades.iloc[8,2]*db_grades.iloc[8,5],'C':db_grades.iloc[8,3]*db_grades.iloc[8,5],'D':db_grades.iloc[8,4]*db_grades.iloc[8,5]}
Scores['P9'] = Grades.iloc[:,9].map(grademap9).to_numpy()
grademap10 = {'A':db_grades.iloc[9,1]*db_grades.iloc[9,5],'B':db_grades.iloc[9,2]*db_grades.iloc[9,5],'C':db_grades.iloc[9,3]*db_grades.iloc[9,5],'D':db_grades.iloc[9,4]*db_grades.iloc[9,5]}
Scores['P10'] = Grades.iloc[:,10].map(grademap10).to_numpy()
grademap11 = {'A':db_grades.iloc[10,1]*db_grades.iloc[10,5],'B':db_grades.iloc[10,2]*db_grades.iloc[10,5],'C':db_grades.iloc[10,3]*db_grades.iloc[10,5],'D':db_grades.iloc[10,4]*db_grades.iloc[10,5]}
Scores['P11'] = Grades.iloc[:,11].map(grademap11).to_numpy()
grademap12 = {'A':db_grades.iloc[11,1]*db_grades.iloc[11,5],'B':db_grades.iloc[11,2]*db_grades.iloc[11,5],'C':db_grades.iloc[11,3]*db_grades.iloc[11,5],'D':db_grades.iloc[11,4]*db_grades.iloc[11,5]}
Scores['P12'] = Grades.iloc[:,12].map(grademap12).to_numpy()
grademap13 = {'A':db_grades.iloc[12,1]*db_grades.iloc[12,5],'B':db_grades.iloc[12,2]*db_grades.iloc[12,5],'C':db_grades.iloc[12,3]*db_grades.iloc[12,5],'D':db_grades.iloc[12,4]*db_grades.iloc[12,5]}
Scores['P13'] = Grades.iloc[:,13].map(grademap13).to_numpy()
grademap14 = {'A':db_grades.iloc[13,1]*db_grades.iloc[13,5],'B':db_grades.iloc[13,2]*db_grades.iloc[13,5],'C':db_grades.iloc[13,3]*db_grades.iloc[13,5],'D':db_grades.iloc[13,4]*db_grades.iloc[13,5]}
Scores['P14'] = Grades.iloc[:,14].map(grademap14).to_numpy()
grademap15 = {'A':db_grades.iloc[14,1]*db_grades.iloc[14,5],'B':db_grades.iloc[14,2]*db_grades.iloc[14,5],'C':db_grades.iloc[14,3]*db_grades.iloc[14,5],'D':db_grades.iloc[14,4]*db_grades.iloc[14,5]}
Scores['P15'] = Grades.iloc[:,15].map(grademap15).to_numpy()
Scores['Iv'] = Scores.iloc[:,1:len(Scores.columns)].sum(axis = 'columns')

#Vi for all buildings
smin_wi = 0
smax_smin = 0
for i in np.arange(0,len(db_grades)):
#choose the minimum score for the parameter we are on
        smin = db_grades.iloc[i,1]
        #choose the maximum score for the parameter we are on
        smax = db_grades.iloc[i,4]
        #choose the maximum score for the parameter we are on
        wi = db_grades.iloc[i,5]
        #sum in the numerator
        smin_wi = smin_wi + smin*wi
        #sum in the denominator
        smax_smin = smax_smin +(smax*wi - smin*wi)
        
#Scores['Vi'] = 1.1*(Scores['Iv']-smin_wi)/smax_smin
Scores['Vi'] = 1*(Scores['Iv']-smin_wi)/smax_smin
#Scores['Iv'] = Scores['Vi']*smax_smin - smin_wi
Scores


# In[34]:


stock


# In[35]:


Scores.to_excel(r'C:\Users\mason\Desktop\MCM SAHC\Courses\SA7 - Integrated Group Project\SA7 Code\Vulnerabilities Vi final.xlsx')


# In[36]:


Vi = Scores['Vi']

M1ind = stock.index[stock['Typology'] == 'M1'].to_numpy()
M1vi = Vi[M1ind]
M1avg = np.mean(M1vi)
M1std = np.std(M1vi)

M2ind = stock.index[stock['Typology'] == 'M2'].to_numpy()
M2vi = Vi[M2ind]
M2avg = np.mean(M2vi)
M2std = np.std(M2vi)

M3ind = stock.index[stock['Typology'] == 'M3'].to_numpy()
M3vi = Vi[M3ind]
M3avg = np.mean(M3vi)
M3std = np.std(M3vi)

M4ind = stock.index[stock['Typology'] == 'M4'].to_numpy()
M4vi = Vi[M4ind]
M4avg = np.mean(M4vi)
M4std = np.std(M4vi)

M5ind = stock.index[stock['Typology'] == 'M5'].to_numpy()
M5vi = Vi[M5ind]
M5avg = np.mean(M5vi)
M5std = np.std(M5vi)

M6ind = stock.index[stock['Typology'] == 'M6'].to_numpy()
M6vi = Vi[M6ind]
M6avg = np.mean(M6vi)
M6std = np.std(M6vi)

M7ind = stock.index[stock['Typology'] == 'M7'].to_numpy()
M7vi = Vi[M7ind]
M7avg = np.mean(M7vi)
M7std = np.std(M7vi)


# In[37]:


print("For Building Type M1 the mean damage grade is",round(M1avg,2),"with a standard deviation of",round(M1std,3))
print("For Building Type M2 the mean damage grade is",round(M2avg,2),"with a standard deviation of",round(M2std,3))
print("For Building Type M3 the mean damage grade is",round(M3avg,2),"with a standard deviation of",round(M3std,3))
print("For Building Type M4 the mean damage grade is",round(M4avg,2),"with a standard deviation of",round(M4std,3))
print("For Building Type M5 the mean damage grade is",round(M5avg,2),"with a standard deviation of",round(M5std,3))
print("For Building Type M6 the mean damage grade is",round(M6avg,2),"with a standard deviation of",round(M6std,3))
print("For Building Type M7 the mean damage grade is",round(M7avg,2),"with a standard deviation of",round(M7std,3))


# In[38]:


lv = Scores[(Scores['Vi']>0.0)&(Scores['Vi']<=0.4)]
mlv = Scores[(Scores['Vi']>0.4)&(Scores['Vi']<=0.6)]
mhv = Scores[(Scores['Vi']>=0.6)&(Scores['Vi']<0.8)]
hv = Scores[(Scores['Vi']>=0.8)&(Scores['Vi']<=1)]
print(round((len(lv)/len(Scores)*100)),"% of buildings surveyed are associated with a low vulnerability index")
print(round((len(mlv)/len(Scores)*100)),"% of buildings surveyed are associated with a medium-low vulnerability index")
print(round((len(mhv)/len(Scores)*100),2),"% of buildings surveyed are associated with a medium-high vulnerability index")
print(round((len(hv)/len(Scores)*100),2),"% of buildings surveyed are associated with a high vulnerability index")


# # Determination of Damage by Intensity

# In[39]:


Damstock = stock
Damstock['Vi'] = Scores['Vi']

#Damage grade vs Intensity per building

MCS = np.arange(5,13)
Q = 2.3

# initalize arrays for data to be placed in
dmg5 = dmg6 = dmg7 = dmg8 = dmg9 = dmg10 = dmg11 = dmg12 = []
grd5 = grd6 = grd7 = grd8 = grd9 = grd10 = grd11 = grd12 = []

for i in np.arange(0,len(stock)):
    dmg5 = np.append(dmg5,2.5*(1+np.tanh((MCS[0]+6.25*Vi[i]-13.1)/Q)))
    if dmg5[i] <= 0.5:
        grd5 = np.append(grd5,'D0')
    elif dmg5[i] <= 1.5:
        grd5 = np.append(grd5,'D1')
    elif dmg5[i] <= 2.5:
        grd5 = np.append(grd5,'D2')
    elif dmg5[i] <= 3.5:
        grd5 = np.append(grd5,'D3')
    elif dmg5[i] <= 4.5:
        grd5 = np.append(grd5,'D4')
    elif dmg5[i] <= 5:
        grd5 = np.append(grd5,'D5')
    
    dmg6 = np.append(dmg6,2.5*(1+np.tanh((MCS[1]+6.25*Vi[i]-13.1)/Q)))
    if dmg6[i] <= 0.5:
        grd6 = np.append(grd6,'D0')
    elif dmg6[i] <= 1.5:
        grd6 = np.append(grd6,'D1')
    elif dmg6[i] <= 2.5:
        grd6 = np.append(grd6,'D2')
    elif dmg6[i] <= 3.5:
        grd6 = np.append(grd6,'D3')
    elif dmg6[i] <= 4.5:
        grd6 = np.append(grd6,'D4')
    elif dmg6[i] <= 5:
        grd6 = np.append(grd6,'D5')
    
    dmg7 = np.append(dmg7,2.5*(1+np.tanh((MCS[2]+6.25*Vi[i]-13.1)/Q)))
    if dmg7[i] <= 0.5:
        grd7 = np.append(grd7,'D0')
    elif dmg7[i] <= 1.5:
        grd7 = np.append(grd7,'D1')
    elif dmg7[i] <= 2.5:
        grd7 = np.append(grd7,'D2')
    elif dmg7[i] <= 3.5:
        grd7 = np.append(grd7,'D3')
    elif dmg7[i] <= 4.5:
        grd7 = np.append(grd7,'D4')
    elif dmg7[i] <= 5:
        grd7 = np.append(grd7,'D5')

    dmg8 = np.append(dmg8,2.5*(1+np.tanh((MCS[3]+6.25*Vi[i]-13.1)/Q)))
    if dmg8[i] <= 0.5:
        grd8 = np.append(grd8,'D0')
    elif dmg8[i] <= 1.5:
        grd8 = np.append(grd8,'D1')
    elif dmg8[i] <= 2.5:
        grd8 = np.append(grd8,'D2')
    elif dmg8[i] <= 3.5:
        grd8 = np.append(grd8,'D3')
    elif dmg8[i] <= 4.5:
        grd8 = np.append(grd8,'D4')
    elif dmg8[i] <= 5:
        grd8 = np.append(grd8,'D5')
        
    dmg9 = np.append(dmg9,2.5*(1+np.tanh((MCS[4]+6.25*Vi[i]-13.1)/Q)))
    if dmg9[i] <= 0.5:
        grd9= np.append(grd9,'D0')
    elif dmg9[i] <= 1.5:
        grd9 = np.append(grd9,'D1')
    elif dmg9[i] <= 2.5:
        grd9 = np.append(grd9,'D2')
    elif dmg9[i] <= 3.5:
        grd9 = np.append(grd9,'D3')
    elif dmg9[i] <= 4.5:
        grd9 = np.append(grd9,'D4')
    elif dmg9[i] <= 5:
        grd9 = np.append(grd9,'D5')
        
    dmg10 = np.append(dmg10,2.5*(1+np.tanh((MCS[5]+6.25*Vi[i]-13.1)/Q)))
    if dmg10[i] <= 0.5:
        grd10 = np.append(grd10,'D0')
    elif dmg10[i] <= 1.5:
        grd10 = np.append(grd10,'D1')
    elif dmg10[i] <= 2.5:
        grd10 = np.append(grd10,'D2')
    elif dmg10[i] <= 3.5:
        grd10 = np.append(grd10,'D3')
    elif dmg10[i] <= 4.5:
        grd10 = np.append(grd10,'D4')
    elif dmg10[i] <= 5:
        grd10 = np.append(grd10,'D5')
        
    dmg11 = np.append(dmg11,2.5*(1+np.tanh((MCS[6]+6.25*Vi[i]-13.1)/Q)))
    if dmg11[i] <= 0.5:
        grd11 = np.append(grd11,'D0')
    elif dmg11[i] <= 1.5:
        grd11 = np.append(grd11,'D1')
    elif dmg11[i] <= 2.5:
        grd11 = np.append(grd11,'D2')
    elif dmg11[i] <= 3.5:
        grd11 =  np.append(grd11,'D3')
    elif dmg11[i] <= 4.5:
        grd11 = np.append(grd11,'D4')
    elif dmg11[i] <= 5:
        grd11 = np.append(grd11,'D5')
        
    dmg12 = np.append(dmg12,2.5*(1+np.tanh((MCS[7]+6.25*Vi[i]-13.1)/Q)))
    if dmg12[i] <= 0.5:
        grd12 = np.append(grd12,'D0')
    elif dmg12[i] <= 1.5:
        grd12 = np.append(grd12,'D1')
    elif dmg12[i] <= 2.5:
        grd12 = np.append(grd12,'D2')
    elif dmg12[i] <= 3.5:
        grd12 = np.append(grd12,'D3')
    elif dmg12[i] <= 4.5:
        grd12 = np.append(grd12,'D4')
    elif dmg12[i] <= 5:
        grd12 = np.append(grd12,'D5')

Damstock['mu for I = 5'] = dmg5
Damstock['Damage Grade for I = 5'] = grd5
Damstock['mu for I = 6'] = dmg6
Damstock['Damage Grade for I = 6'] = grd6
Damstock['mu for I = 7'] = dmg7
Damstock['Damage Grade for I = 7'] = grd7
Damstock[' for I = 8'] = dmg8
Damstock['Damage Grade for I = 8'] = grd8
Damstock['mu for I = 9'] = dmg9
Damstock['Damage Grade for I = 9'] = grd9
Damstock['mu for I = 10'] = dmg10
Damstock['Damage Grade for I = 10'] = grd10
Damstock['mu for I = 11'] = dmg11
Damstock['Damage Grade for I = 11'] = grd11
Damstock['mu for I = 12'] = dmg12
Damstock['Damage Grade for I = 12'] = grd12


# In[40]:


Damstock.to_excel(r'C:\Users\mason\Desktop\MCM SAHC\Courses\SA7 - Integrated Group Project\SA7 Code\Damage Scores final.xlsx')


# ## Normalized Vulnerability Index for Building 1

# In[41]:


for i in np.arange(0,len(db_grades)):
    smin = db_grades.iloc[i,1]
    smax = db_grades.iloc[i,4]
    wi = db_grades.iloc[i,5]
    #sum in the numerator
    smin_wi = smin_wi + smin*wi
    #sum in the denominator
    smax_smin = smax_smin +(smax*wi - smin*wi)

Vi1 = (Iv-smin_wi)/smax_smin
print("Vi for Building 1 =", Vi1)
Ivup = Vi1


# In[42]:


Iv


# # Graphing of Mean Vulnerability Curves

# In[43]:


MCS = np.arange(5,13)
Q = 2.3
# mn is mean
# p is + 1 standard deviation
# m is - 1 standard deviation
# pp is + 2 standard deviations
# mm is - 2 standard deviations

# initalize arrays for data to be placed in
mn_dmg1 = mn_dmg2 = mn_dmg3 = mn_dmg4 = mn_dmg5 = mn_dmg6 = mn_dmg7 = []
p_dmg1 = p_dmg2 = p_dmg3 = p_dmg4 = p_dmg5 = p_dmg6 = p_dmg7 = []
pp_dmg1 = pp_dmg2 = pp_dmg3 = pp_dmg4 = pp_dmg5 = pp_dmg6 = pp_dmg7 = []
m_dmg1 = m_dmg2 = m_dmg3 = m_dmg4 = m_dmg5 = m_dmg6 = m_dmg7 = []
mm_dmg1 = mm_dmg2 = mm_dmg3 = mm_dmg4 = mm_dmg5 = mm_dmg6 = mm_dmg7 = []

for i in np.arange(0,len(MCS)):
    # for M1
    if len(M1ind) > 0:
        mn_dmg1 = np.append(mn_dmg1,2.5*(1+np.tanh((MCS[i]+6.25*M1avg-13.1)/Q)))
        p_dmg1 = np.append(p_dmg1,2.5*(1+np.tanh((MCS[i]+6.25*(M1avg+M1std)-13.1)/Q)))
        pp_dmg1 = np.append(pp_dmg1,2.5*(1+np.tanh((MCS[i]+6.25*(M1avg+2*M1std)-13.1)/Q)))
        m_dmg1 = np.append(m_dmg1,2.5*(1+np.tanh((MCS[i]+6.25*(M1avg-M1std)-13.1)/Q)))
        mm_dmg1 = np.append(mm_dmg1,2.5*(1+np.tanh((MCS[i]+6.25*(M1avg-2*M1std)-13.1)/Q)))
    # for M2
    if len(M2ind) > 0:
        mn_dmg2 = np.append(mn_dmg2,2.5*(1+np.tanh((MCS[i]+6.25*M2avg-13.1)/Q)))
        p_dmg2 = np.append(p_dmg2,2.5*(1+np.tanh((MCS[i]+6.25*(M2avg+M2std)-13.1)/Q)))
        pp_dmg2 = np.append(pp_dmg2,2.5*(1+np.tanh((MCS[i]+6.25*(M2avg+2*M2std)-13.1)/Q)))
        m_dmg2 = np.append(m_dmg2,2.5*(1+np.tanh((MCS[i]+6.25*(M2avg-M2std)-13.1)/Q)))
        mm_dmg2 = np.append(mm_dmg2,2.5*(1+np.tanh((MCS[i]+6.25*(M2avg-2*M2std)-13.1)/Q)))
    # for M3
    if len(M3ind) > 0:
        mn_dmg3 = np.append(mn_dmg3,2.5*(1+np.tanh((MCS[i]+6.25*M3avg-13.1)/Q)))
        p_dmg3 = np.append(p_dmg3,2.5*(1+np.tanh((MCS[i]+6.25*(M3avg+M3std)-13.1)/Q)))
        pp_dmg3 = np.append(pp_dmg3,2.5*(1+np.tanh((MCS[i]+6.25*(M3avg+2*M3std)-13.1)/Q)))
        m_dmg3 = np.append(m_dmg3,2.5*(1+np.tanh((MCS[i]+6.25*(M3avg-M3std)-13.1)/Q)))
        mm_dmg3 = np.append(mm_dmg3,2.5*(1+np.tanh((MCS[i]+6.25*(M3avg-2*M3std)-13.1)/Q)))
    # for M4
    if len(M4ind) > 0:
        mn_dmg4 = np.append(mn_dmg4,2.5*(1+np.tanh((MCS[i]+6.25*M4avg-13.1)/Q)))
        p_dmg4 = np.append(p_dmg4,2.5*(1+np.tanh((MCS[i]+6.25*(M4avg+M4std)-13.1)/Q)))
        pp_dmg4 = np.append(pp_dmg4,2.5*(1+np.tanh((MCS[i]+6.25*(M4avg+2*M4std)-13.1)/Q)))
        m_dmg4 = np.append(m_dmg4,2.5*(1+np.tanh((MCS[i]+6.25*(M4avg-M4std)-13.1)/Q)))
        mm_dmg4 = np.append(mm_dmg4,2.5*(1+np.tanh((MCS[i]+6.25*(M4avg-2*M4std)-13.1)/Q)))
    # for M5
    if len(M5ind) > 0:
        mn_dmg5 = np.append(mn_dmg5,2.5*(1+np.tanh((MCS[i]+6.25*M5avg-13.1)/Q)))
        p_dmg5 = np.append(p_dmg5,2.5*(1+np.tanh((MCS[i]+6.25*(M5avg+M5std)-13.1)/Q)))
        pp_dmg5 = np.append(pp_dmg5,2.5*(1+np.tanh((MCS[i]+6.25*(M5avg+2*M5std)-13.1)/Q)))
        m_dmg5 = np.append(m_dmg5,2.5*(1+np.tanh((MCS[i]+6.25*(M5avg-M5std)-13.1)/Q)))
        mm_dmg5 = np.append(mm_dmg5,2.5*(1+np.tanh((MCS[i]+6.25*(M5avg-2*M5std)-13.1)/Q)))
    # for M6
    if len(M6ind) > 0:
        mn_dmg6 = np.append(mn_dmg6,2.5*(1+np.tanh((MCS[i]+6.25*M6avg-13.1)/Q)))
        p_dmg6 = np.append(p_dmg6,2.5*(1+np.tanh((MCS[i]+6.25*(M6avg+M6std)-13.1)/Q)))
        pp_dmg6 = np.append(pp_dmg6,2.5*(1+np.tanh((MCS[i]+6.25*(M6avg+2*M6std)-13.1)/Q)))
        m_dmg6 = np.append(m_dmg6,2.5*(1+np.tanh((MCS[i]+6.25*(M6avg-M6std)-13.1)/Q)))
        mm_dmg6 = np.append(mm_dmg6,2.5*(1+np.tanh((MCS[i]+6.25*(M6avg-2*M6std)-13.1)/Q)))
    # for M7
    if len(M7ind) > 0:
        mn_dmg7 = np.append(mn_dmg7,2.5*(1+np.tanh((MCS[i]+6.25*M7avg-13.1)/Q)))
        p_dmg7 = np.append(p_dmg7,2.5*(1+np.tanh((MCS[i]+6.25*(M7avg+M7std)-13.1)/Q)))
        pp_dmg7 = np.append(pp_dmg7,2.5*(1+np.tanh((MCS[i]+6.25*(M7avg+2*M7std)-13.1)/Q)))
        m_dmg7 = np.append(m_dmg7,2.5*(1+np.tanh((MCS[i]+6.25*(M7avg-M7std)-13.1)/Q)))
        mm_dmg7 = np.append(mm_dmg7,2.5*(1+np.tanh((MCS[i]+6.25*(M7avg-2*M7std)-13.1)/Q)))


# In[46]:


# Graph the mean damage curves for all building typologies shown
plt.rcParams.update({'font.size': 12})
fig,axs = plt.subplots(2, 2, figsize = (14,10))
if len(M1ind) > 0:
    axs[0,0].set_title('M1 Typology Mean Damage Curve')
    axs[0,0].plot(MCS,mn_dmg1, color = 'red', label = '$V_i$', marker = '.', lw = 1.5)
    axs[0,0].plot(MCS,p_dmg1, color = 'darkolivegreen', lw = 1, label = '$V_i + \sigma$')
    axs[0,0].plot(MCS,pp_dmg1, color = 'yellowgreen', lw = 1, label = '$V_i + 2 \sigma$')
    axs[0,0].plot(MCS,m_dmg1, color = 'purple', lw = 1, label = '$V_i - \sigma$')
    axs[0,0].plot(MCS,mm_dmg1, color = 'm', lw = 1, label = '$V_i - 2\sigma$')
    axs[0,0].grid(True)
    axs[0,0].set_xlabel('Intensity')
    axs[0,0].legend()
    axs[0,0].set_ylabel('Mean Damage Grade $\mu_D$')
    axs[0,0].set_ylim(0,5)
    axs[0,0].set_facecolor("white")
    axs[0,0].tick_params(color='black', labelcolor='black')
    axs[0,0].grid(True, linestyle='-.', color = 'black', lw = 0.5)
    axs[0,0].spines['bottom'].set_color('black')
    axs[0,0].spines['top'].set_color('black')
    axs[0,0].spines['left'].set_color('black')
    axs[0,0].spines['right'].set_color('black')

if len(M5ind) > 0:
    axs[0,1].set_title('M5 Typology Mean Damage Curve')
    axs[0,1].plot(MCS,mn_dmg5, color = 'red', label = '$V_i$', marker = '.')
    axs[0,1].plot(MCS,p_dmg5, color = 'darkolivegreen', lw = .75, label = '$V_i + \sigma$')
    axs[0,1].plot(MCS,pp_dmg5, color = 'yellowgreen', lw = .75, label = '$V_i + 2 \sigma$')
    axs[0,1].plot(MCS,m_dmg5, color = 'purple', lw = .75, label = '$V_i - \sigma$')
    axs[0,1].plot(MCS,mm_dmg5, color = 'm', lw = 0.75, label = '$V_i - 2\sigma$')
    axs[0,1].grid(True)
    axs[0,1].set_xlabel('Intensity')
    axs[0,1].legend()
    axs[0,1].set_ylabel('Mean Damage Grade $\mu_D$')
    axs[0,1].set_ylim(0,5)
    axs[0,1].set_facecolor("white")
    axs[0,1].tick_params(color='black', labelcolor='black')
    axs[0,1].grid(True, linestyle='-.', color = 'black', lw = 0.5)
    axs[0,1].spines['bottom'].set_color('black')
    axs[0,1].spines['top'].set_color('black')
    axs[0,1].spines['left'].set_color('black')
    axs[0,1].spines['right'].set_color('black')

if len(M6ind) > 0:
    axs[1,0].set_title('M6 Typology Mean Damage Curve')
    axs[1,0].plot(MCS,mn_dmg6, color = 'red', label = '$V_i$', marker = '.')
    axs[1,0].plot(MCS,p_dmg6, color = 'darkolivegreen', lw = .75, label = '$V_i + \sigma$')
    axs[1,0].plot(MCS,pp_dmg6, color = 'yellowgreen', lw = .75, label = '$V_i + 2 \sigma$')
    axs[1,0].plot(MCS,m_dmg6, color = 'purple', lw = .75, label = '$V_i - \sigma$')
    axs[1,0].plot(MCS,mm_dmg6, color = 'm', lw = 0.75, label = '$V_i - 2\sigma$')
    axs[1,0].grid(True)
    axs[1,0].set_xlabel('Intensity')
    axs[1,0].legend()
    axs[1,0].set_ylabel('Mean Damage Grade $\mu_D$')
    axs[1,0].set_ylim(0,5)
    axs[1,0].set_facecolor("white")
    axs[1,0].tick_params(color='black', labelcolor='black')
    axs[1,0].grid(True, linestyle='-.', color = 'black', lw = 0.5)
    axs[1,0].spines['bottom'].set_color('black')
    axs[1,0].spines['top'].set_color('black')
    axs[1,0].spines['left'].set_color('black')
    axs[1,0].spines['right'].set_color('black')

if len(M7ind) > 0:
    axs[1,1].set_title('M7 Typology Mean Damage Curve')
    axs[1,1].plot(MCS,mn_dmg7, color = 'red', label = '$V_i$', marker = '.')
    axs[1,1].plot(MCS,p_dmg7, color = 'darkolivegreen', lw = .75, label = '$V_i + \sigma$')
    axs[1,1].plot(MCS,pp_dmg7, color = 'yellowgreen', lw = .75, label = '$V_i + 2 \sigma$')
    axs[1,1].plot(MCS,m_dmg7, color = 'purple', lw = .75, label = '$V_i - \sigma$')
    axs[1,1].plot(MCS,mm_dmg7, color = 'm', lw = 0.75, label = '$V_i - 2\sigma$')
    axs[1,1].grid(True)
    axs[1,1].set_xlabel('Intensity')
    axs[1,1].legend()
    axs[1,1].set_ylabel('Mean Damage Grade $\mu_D$')
    axs[1,1].set_ylim(0,5)
    axs[1,1].set_facecolor("white")
    axs[1,1].tick_params(color='black', labelcolor='black')
    axs[1,1].grid(True, linestyle='-.', color = 'black', lw = 0.5)
    axs[1,1].spines['bottom'].set_color('black')
    axs[1,1].spines['top'].set_color('black')
    axs[1,1].spines['left'].set_color('black')
    axs[1,1].spines['right'].set_color('black')


# In[47]:


# Graph the mean damage curves for all building typologies shown

fig,axs = plt.subplots(figsize = (16,8))
axs.set_title('M1 Typology Mean Damage Curve')
axs.plot(MCS,mn_dmg1, color = 'red', label = '$V_i$ M1' , marker = '.')
axs.plot(MCS,mn_dmg5, color = 'darkolivegreen', label = '$V_i$ M5')
axs.plot(MCS,mn_dmg6, color = 'purple', label = '$V_i$ M6')
axs.grid(True)
axs.set_xlabel('Intensity')
axs.legend()
axs.set_ylabel('Mean Damage Grade $\mu_D$')
axs.set_ylim(0,5)


# In[ ]:





# # Below here are unfinished or in progress code snippets to be implemented later, they are intended to run faster and more efficiently that existing code

# In[128]:


#TO DO

for i in np.arange(0,len(Grades)):
    bldg_grades = Grades.iloc[i,1:len(Grades.columns)]
    bldg_iv_comps = []
    bldg_Iv = np.zeros(len(Grades))
    for k in np.arange(0,len(bldg_grades)):
        grademap = {'A':db_grades.iloc[k,1],'B':db_grades.iloc[k,2],'C':db_grades.iloc[k,3],'D':db_grades.iloc[k,4]}
        Grades.iloc[:,k+1].map(grademap).to_numpy()
    score = db_grades.iloc[i,ind]
    weight = db_grades.iloc[i,5]
    iv_comps = np.append(iv_comps, s*wt)
    bldg_Iv[i] = sum(iv_comps)
bldg_Iv


# In[129]:


#Fix later, to try to loop the grading
p1s = []
p2s = []
p3s = []
p4s = []
p5s = []
p6s = []
p7s = []
p8s = []
p9s = []
p10s = []
p11s = []
p12s = []
p13s = []
p14s = []
p15s = []
scores = np.zeros(Grades.shape())
Scores = base.drop(columns = {'Building No.'})
#loop over each parameter
for i in np.arange(0,len(db_grades)):
    #isolate row with grades for 
    bldg_iv_comps = []
    bldg_Iv = np.zeros(len(Grades))
    #generate mapping for scores to grades
    grademap = {'A':db_grades.iloc[i,1]*db_grades.iloc[i,5],'B':db_grades.iloc[i,2]*db_grades.iloc[i,5],'C':db_grades.iloc[i,3]*db_grades.iloc[i,5],'D':db_grades.iloc[i,4]*db_grades.iloc[i,5]}
    #map onto the grades for the given parameter
    grades_replaced = Grades.iloc[:,i+1].map(grademap).to_numpy()
    i*len(Grades)
    
    


# In[ ]:





# In[ ]:





# In[56]:


tau = db.iloc[:,[12]].to_numpy()*1000
N = db.iloc[:,[13]].to_numpy()
Aplan = db.iloc[:,[14]].to_numpy()
hb = db.iloc[:,[15]].to_numpy()
pm = db.iloc[:,[16]].to_numpy()*.009806
wd = db.iloc[:,[17]].to_numpy()
Lx = db.iloc[:,[18]].to_numpy()
tx = db.iloc[:,[19]].to_numpy()
Ly = db.iloc[:,[20]].to_numpy()
ty = db.iloc[:,[21]].to_numpy()
Ax = Lx*tx
Ay = Ly*ty
hm = np.zeros(len(Ax))
A = np.zeros(len(Ax))
B = np.zeros(len(Ax))
q = np.zeros(len(Ax))
a_o = np.zeros(len(Ax))
alpha = np.zeros(len(Ax))
hm[0] = hb[0]/N[0]
A[0] = min(Ax[0],Ay[0])
B[0] = max(Ax[0],Ay[0])
a_o[0] = A[0]/Aplan[0]
q[0] = (A[0]+B[0])/Aplan[0]*hm[0]*pm[0]+wd[0]
alpha[0] = ((a_o[0]*tau[0]/(N[0]*q[0]))*((1+(q[0]*N[0])/(1.5*a_o[0]*tau[0]*(1+B[0]/A[0])))**.5))/0.4
Lx


# In[30]:


p4 = []
tau = db.iloc[:,[tau_k_ind]].to_numpy()*1000
N = db.iloc[:,[N_ind]].to_numpy()
Aplan = db.iloc[:,[A_plan_ind]].to_numpy()
hb = db.iloc[:,[h_b_ind]].to_numpy()
pm = db.iloc[:,[p_m_ind]].to_numpy()*.009806
wd = db.iloc[:,[w_d_ind]].to_numpy()
Lx = db.iloc[:,[Lx_ind]].to_numpy()
tx = db.iloc[:,[tx_ind]].to_numpy()
Ly = db.iloc[:,[Ly_ind]].to_numpy()
ty = db.iloc[:,[ty_ind]].to_numpy()
Ax = Lx*tx
Ay = Ly*ty
hm = np.zeros(len(Ax))
A = np.zeros(len(Ax))
B = np.zeros(len(Ax))
q = np.zeros(len(Ax))
a_o = np.zeros(len(Ax))
alpha = np.zeros(len(Ax))
for i in np.arange(0,len(Ax)):
    if hm[i] == -1 or A[i] == -1 or B[i] == -1 or a_o[i] == -1:
        p4 = np.append(p4, 'D')
    else:
        hm[i] = hb[i]/N[i]
        A[i] = min(Ax[i],Ay[i])
        B[i] = max(Ax[i],Ay[i])
        a_o[i] = A[i]/Aplan[i]
        q[i] = (A[i]+B[i])/Aplan[i]*hm[i]*pm[i]+wd[i]
        alpha[i] = ((a_o[i]*tau[i]/(N[i]*q[i]))*((1+(q[i]*N[i])/(1.5*a_o[i]*tau[i]*(1+B[i]/A[i])))**.5))/0.4
        if alpha[i] >= 1:
            p4 = np.append(p4, 'A')
        elif 0.6 <= alpha[i] < 1:
            p4 = np.append(p4, 'B')
        elif 0.4 <= alpha[i] < 0.6:
            p4 = np.append(p4, 'C')
        elif alpha[i] < 0.4:
            p4 = np.append(p4, 'D')


# In[ ]:


#USE SOMEWHERE?
Tot_Buildings = len(db['Building No.'])-db['Building No.'].isna().sum()
Tot_Buildings

